.\"	$NetBSD$
.\"
.\" Copyright (c) 2008-2009 by Aleksey Cheusov (vle@gmx.net)
.\" Absolutely no warranty.
.\"
.\" ------------------------------------------------------------------
.de VB \" Verbatim Begin
.ft CW
.nf
.ne \\$1
..
.de VE \" Verbatim End
.ft R
.fi
..
.\" ------------------------------------------------------------------
.TH LMDBG-RUN 1 "May 9, 2009" "" ""
.SH NAME
lmdbg-run \- runs a program and traces the malloc/realloc/free calls
.SH SYNOPSIS
.BI lmdbg-run " [OPTIONS] <prog> [args...]"
.SH DESCRIPTION
.B lmdbg-run
lmdbg-run runs an external command
.I prog args
and creates a log file where all
invocations of
.IR malloc ", " calloc ", " realloc ", " memalign ", "
.IR posix_memalign " and " free
are registered accompanied by the following information: full stacktrace
(addresses), input argument(s) (requested size and/or address) and
result value (returned address, if any). Before being saved to the log file,
stacktrace info can be filtered through a custom command.
Example of
.B lmdbg-run
output:
.VB

 realloc ( 0xbb901800 , 777 ) --> 0xbb901c00
  0xbbbe58e8
  0xbbbe5a37
  0x8048764
  0x8048584
  0x80484e7

.VE
This output means that
.I realloc
function was given the pointer 0xbb901800 and 777
bytes were requested. As a result
.I realloc
returned the address 0xbb901c00.
Addresses 0xbbbe58e8, 0xbbbe5a37 etc. are a part of the stacktrace. Another example:
.VB

$ cat tests/test2.c
#include <stdlib.h>

int main ()
{
   void *p1 = NULL;
   void *p2 = NULL;

   p1 = malloc (555);
   p2 = realloc (p2, 666);
   p2 = realloc (p2, 777);
   p2 = realloc (p2, 888);

   return 0;
}
$ cc -O0 -g -o test2 tests/test2.c
$ lmdbg-run -o log ./test2 
$ cat log
malloc ( 555 ) --> 0xbb901400
 0xbbbe58e8
 0xbbbe5b03
 0x8048738
 0x8048584
 0x80484e7
realloc ( NULL , 666 ) --> 0xbb901800
 0xbbbe58e8
 0xbbbe5a37
 0x804874e
 0x8048584
 0x80484e7
realloc ( 0xbb901800 , 777 ) --> 0xbb901c00
 0xbbbe58e8
 0xbbbe5a37
 0x8048764
 0x8048584
 0x80484e7
realloc ( 0xbb901c00 , 888 ) --> 0xbb901800
 0xbbbe58e8
 0xbbbe5a37
 0x804877a
 0x8048584
 0x80484e7
$

.VE
.SH OPTIONS
.TP
.B "-h"
Display the help message.
.TP
.BI "-V"
Display the lmdbg version.
.TP
.B "-v"
Enable verbose mode.
.TP
.BI "-o" " filename"
Specify the log file name.
.TP
.BI "-f" " command"
Filter stacktrace through a filtering command/pipe.
The result is sent to the log file specified in -o option or to stdout otherwise.
.TP
.BI "-p" " pipe"
(obsolete) Same as -f. 
.TP
.B "-n"
Do not enable logging on startup. To enable it, send SIGUSR1 signal to the
process.
.TP
.BI "-T" " number"
Specify the number of addresses to skip from the top of the stacktrace (farther from function main).
.TP
.BI "-B" " number"
Specify the number of addresses to skip from the bottom of the stacktrace (nearer to function main).
.TP
.BI "-M" " number"
Limit the number of addresses shown in a stacktrace. An incomplete stacktrace
may be generated, that includes the top of the stack.
.SH ENVIRONMENT
.TP
.B LMDBG_LIB
Path to LD_PRELOAD'ed liblmdbg dynamic library. It defaults to
@libdir@/liblmdbg.so
.SH EXAMPLES
.VB
lmdbg-run -h
lmdbg-run -V
lmdbg-run -o log ./my_app &&
  lmdbg-leaks log > log_leaks &&
  lmdbg-sym ./my_app log_leaks > log_leaks2 &&
  lmdbg-sysleaks -s log_leaks2 > log_final
lmdbg-run -B2 -M6 -f 'lmdbg-leaks | lmdbg-sym > log' ./my_app <args>
.VE
.SH NOTES
Full stacktrace allows analysing an application on per-module
basis. It helps determine what libraries and/or components require
more memory than others and why. See
.B lmdbg-stat
and
.BR lmdbg-sort .
.SH BUGS
The current implementation of
.B lmdbg-run
relies on several GCC's extensions, namely, __builtin_return_address,
__builtin_frame_address, __attribute__((constructor)) and
__attribute__((destructor)). In my knowledge, Besides GCC these extensions are also
supported by Intel C compiler. If you know a solution that works for
other compilers let me now ;-)
.SH SEE ALSO
.BR lmdbg-sym(1) ,
.BR lmdbg-leaks(1) ,
.BR lmdbg-sysleaks(1) ,
.BR lmdbg-stat(1) ,
.BR lmdbg-sort(1) ,
.B lmdbg(1)
.SH AUTHOR
Aleksey Cheusov <vle@gmx.net>
