#!/bin/sh

# Copyright (c) 2003-2009 Aleksey Cheusov <vle@gmx.net>
# 
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
# 
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

set -e

LC_ALL=C
export LC_ALL

libdir=@libdir@
sysconfdir=@sysconfdir@

LMDBG_SOEXT=${LMDBG_SOEXT:-so}
LMDBG_LIB=${LMDBG_LIB:-$libdir/liblmdbg.$LMDBG_SOEXT}
LMDBG_GDB=${LMDBG_GDB:-gdb}

usage (){
    echo -n "\
lmdbg-sym analyses lmdbg-run's output and converts
function addresses to source code position.
Set LMDBG_LIB environment variable to liblmdbg.so
The default is $libdir/liblmdbg.so.

usage:
    lmdbg-sym [OPTIONS] <prog> [files...]
OPTIONS:
    -h --help        displays this screen
    -V --version     display version
    -g --with-gdb    use 'gdb' for resolving (the default).
    -a               use 'addr2line' for resolving. By default 'gdb' is used.
       --with-so <filename> <flags>
                     dlopen(3) specified libraries with specified flags.
                     Possible flags are: RTLD_LAZY, RTLD_NOW and RTLD_GLOBAL
"
}

version (){
cat <<EOF
lmdbg-sym @LMDBG_VERSION@
EOF
}

additional_libs=

with_gdb=1

while [ $# -ne 0 ]; do
    case $1 in
	-h|--help)
	    usage
	    exit 0;;
	-V|--version)
	    version
	    exit 0;;
	-g|--with-gdb)
	    with_gdb=1;;
	-a)
	    with_gdb='';;
        --with-so)
	    additional_libs="${additional_libs},$2:$3"
	    shift
	    shift;;
	--)
	    shift
	    break;;
	-*)
	    echo "unknown option '$1'" 1>&2
	    exit 1;;
	*)
	    break;;
    esac

    shift
done

#echo "additional_libs=$additional_libs" 1>&2

if test $# -lt 1; then
    echo "Run lmdbg-sym --help for help"
    exit 1
fi

prog=$1
shift

tmp_dir="/tmp/lmdbg-sym.$$"
trap "rm -rf $tmp_dir" 0 1 2 15
mkdir -m 700 "$tmp_dir"

input=$tmp_dir/0
tmp_file1=$tmp_dir/1
tmp_file3=$tmp_dir/3
pid_file=$tmp_dir/4
gdb_cmds_file=$tmp_dir/5
info_sections_fn=$tmp_dir/6

if test $# -ne 1; then
    cat "$@" > "$input"
else
    input=$1
fi

test $? || exit 3

collect_address (){
    # input: text files in lmdbg-run format
    # output: all addresses (uniqued) mensioned in input

    awk '
$0 ~ /^ / && NF == 1 {
    hash [$1] = ""
}
END {
    for (addr in hash){
	print addr
    }
}' "$@"
}

generate_gdb_commands (){
    # input: addresses, one per line
    # output: gdb command for converting addresses to source position

    echo 'set width 0'
    echo 'break main'
    echo 'set print demangle on'
    echo "set environment LD_PRELOAD=$LMDBG_LIB $LMDBG_ENV"
#   echo "set environment LMDBG_PIDFILE=$pid_file"
    if test "$additional_libs"; then
	echo "set environment LMDBG_ADD_LIBS=$additional_libs"
    fi
    echo 'run'
#   echo 'p print_pid()'
#   echo 'p lmdbg_dlopen_add_libs()'
    echo 'print/x 0x22552255'

    if grep '^info section ' "$input" > "$info_sections_fn"; then
	awk '
	BEGIN {
	    br_cnt = 2
	}
	$1 == "info" && $2 == "section" {
	    sub(/^(0x)?0*/, "", $3)
	    sub(/^(0x)?0*/, "", $4)
	    if ($5 in beg){
#		print "BAD! " $5 > "/dev/stderr"
		dup [$5] = 1
	    }else{
		beg [$5] = ($3 "")
		end [$5] = ($4 "")
	    }
	    next
	}
	{
	    sub(/^(0x)?0*/, "", $0)
	    module = ""
	    beg_addr = 0
	    for (sect in beg){
		if ($0 >= beg [sect] && $0 < end [sect]){
		    module   = sect
		    beg_addr = beg [sect]
		    break
		}
	    }

	    if (sect in dup) next

	    printf "print/x 0x%s\n", $0
	    printf "break *lmdbg_get_addr(0x%s, 0x%s, \"%s\")\n", $0, beg_addr, module
	    printf "info break %s\n", br_cnt++
	}' "$info_sections_fn" "$@"
    else
	awk '{
	    if ($0 !~ /^0x/)
		$0 = "0x" $0 # This is necessary for Solaris
	    print "b *" $0 "\ninfo break " NR+1
	}' "$@"
    fi
    echo 'quit'
}

address2position_gdb (){
    # input: addresses, one per line
    # output: source code positions, one per line

    generate_gdb_commands "$@" > "$gdb_cmds_file"

    $LMDBG_GDB -nx -q -batch -x "$gdb_cmds_file" "$prog" | #| tee log |
    awk '
    !flag {
	flag = /22552255/
	next
    }
    $1 ~ /^[$]/ && $2 == "=" {
	addr = $3
    }
    $1 == "Breakpoint" { # result of `b *<address>` command
	if (!addr){
	    addr = $4
	    sub(/:+$/, "", addr)
	}
	printf "%s\t", addr
	for (i=1; i <= NF; ++i){
	    if ($i == "file"){
		gsub(/[,.]$/, "", $(i+1))
		printf "%s:", $(i+1)
	    }
	    if ($i == "line"){
		gsub(/[,.]$/, "", $(i+1))
		printf "%s", $(i+1)
	    }
	}

	addr = ""
	next
    }
    $2 == "breakpoint" { # result of `info break <NUM>` command
	if (match($0, / in .* at /)){
	    print "\t" substr($0, RSTART+4, RLENGTH-8)
	}else{
	    print ""
	}

	next
    }
    '
}

address2position_addr2line_nomaps (){
    # input: addresses, one per line
    # output: source code positions, one per line

    info_fn=$tmp_dir/info
    xargs addr2line -e "$prog" < "$tmp_file1" > "$info_fn"
    awk -v tmp_file1="$tmp_file1" -v info_fn="$info_fn" '
    BEGIN {
	while ((getline addr < tmp_file1) > 0 &&
	        (getline info < info_fn) > 0)\
	{
	    print addr "\t" info
        }
    }
    '
}

#address2position_addr2line_maps (){
#    # input: addresses, one per line
#    # output: source code positions, one per line
#    grep 'info section ' "$input"
#}

collect_address "$input" > "$tmp_file1"

if test "_$with_gdb" = "_1"; then
    # command file for GDB
    address2position_gdb "$tmp_file1"
#elif grep '^info section' "$input" > /dev/null; then
#    address2position_addr2line_maps "$tmp_file1"
else
    # ADDR2LINE 
    address2position_addr2line_nomaps "$tmp_file1"
fi > $tmp_file3

#cat $tmp_file3
#exit

awk -v tmp3=$tmp_file3 '
BEGIN {
    FS="\t"
    while (0 < (getline < tmp3)){
	if (NF > 1 && $2 != "??:0"){
	    addr = $1
	    sub(/^[^\t]*\t/, "", $0)
	    h [addr] = $0
	}
    }
    FS = " "
}
NF == 1 && $0 ~ /^ / {
    if ($1 !~ /^0x/)
	$1 = "0x" $1 # This is necessary for Solaris

    if ($1 in h){
	print " " $1 "\t" h [$1]
    }else{
	print " " $1
    }

    next
}
$1 == "info" && $2 == "section" { next }
{
    print $0
}' < "$input"
